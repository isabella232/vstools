/***************************************************************************************************
 Copyright (C) 2023 The Qt Company Ltd.
 SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GFDL-1.3-only
***************************************************************************************************/

/*!
    \page index.html

    \title Qt VS Tools

    Qt VS Tools integrate the Qt development tools into Microsoft Visual Studio
    2019, and later. You can use the standard Windows development environment
    without having to worry about Qt-related build steps or tools. Install and
    update Qt VS Tools directly from Microsoft Visual Studio.

    \table
        \row
            \li \inlineimage tutorials.webp
            \li \inlineimage how-to.webp
            \li \inlineimage explanation.webp
            \li \inlineimage reference.webp
        \row
            \li \b {Tutorials}
                \list
                    \li \l {Tutorial: Qt Widgets application}
                    \li \l {Tutorial: Qt Quick application}
                    \li \l {Tutorial: Qt Quick debugging}
                \endlist
            \li \b {How-to}
                \list
                    \li \l {Install Qt VS Tools}
                    \li \l {Add Qt versions}
                    \li \l {Select Qt versions for a project}
                    \li \l {Convert solutions to latest Qt/MSBuild format}
                    \li \l {Build solutions that have Qt/MSBuild format 2}
                    \li \l {Load Qt projects}
                    \li \l {Debug applications}
                    \li \l {Enable QML debugging}
                    \li \l {How-to}{See all}
                \endlist
        \li \b {Explanation}
            \list
                \li \l {Building}
                \li \l {Configuring builds}
                \li \l {Debugging Qt Quick applications}
                \li \l {Features}
            \endlist
        \li \b {Reference}
            \list
                \li \l {Files}
                \li \l {Projects}
            \endlist
    \endtable
*/

/*!
    \page qtvstools-toc.html
    \title All Topics

    \list
        \li Tutorials
            \list
                \li \l {Tutorial: Qt Widgets application}
                \li \l {Tutorial: Qt Quick application}
                \li \l {Tutorial: Qt Quick debugging}
            \endlist
        \li How-to
            \list
                \li \l {Add Qt versions}
                \li \l {Build solutions that have Qt/MSBuild format 2}
                \li \l {Convert solutions to latest Qt/MSBuild format}
                \li \l {Create Qt translation files}
                \li \l {Create UI form files}
                \li \l {Cross-compile}
                \li \l {Debug applications}
                \li \l {Debug on Linux}
                \li \l {Enable QML debugging}
                \li \l {Get help}
                \li \l {Install Qt VS Tools}
                \li \l {Load Qt projects}
                \li \l {Manage resources}
                \li \l {Select Qt versions for a project}
                \li \l {Start Qt Designer}
                \li \l {Start Qt Linguist}
                \li \l {Start Qt Resource Editor}
                \li \l {Update IntelliSense info}
                \li \l {Update Qt translation files}
            \endlist

        \li Explanation
            \list
                \li \l {Building}
                \li \l {Configuring builds}
                \li \l {Debugging Qt Quick applications}
                \li \l {Features}
            \endlist
        \li Reference
            \list
                \li \l {Files}
                \li \l {Projects}
            \endlist

    \endlist
*/

/*!
    \page qtvstools-how-to.html

    \title How-to

        \list
        \li \l {Add Qt versions}
        \li \l {Build solutions that have Qt/MSBuild format 2}
        \li \l {Convert solutions to latest Qt/MSBuild format}
        \li \l {Create Qt translation files}
        \li \l {Create UI form files}
        \li \l {Cross-compile}
        \li \l {Debug applications}
        \li \l {Debug on Linux}
        \li \l {Enable QML debugging}
        \li \l {Get help}
        \li \l {Install Qt VS Tools}
        \li \l {Load Qt projects}
        \li \l {Manage resources}
        \li \l {Select Qt versions for a project}
        \li \l {Start Qt Designer}
        \li \l {Start Qt Linguist}
        \li \l {Start Qt Resource Editor}
        \li \l {Update IntelliSense info}
        \li \l {Update Qt translation files}
    \endlist
*/

/*!
    \page qtvstools-explanation-features.html
    \ingroup qtvstools-explanation

    \title Features

    The main features of Qt VS Tools are:

    \list
        \li Wizards for creating new Qt and Qt Quick projects and files.
        \li Automated build setup for \l {Using the Meta-Object Compiler
            (moc)}{Meta-Object Compiler (moc)}, \l {User Interface Compiler
            (uic)}, and \l {Resource Compiler (rcc)}.
        \li Loading existing Qt projects (\c .pro).
        \li Using CMake for cross-platform development.
        \li Integrated Qt resource management.
        \li Creating a Qt translation source (TS) file and starting Qt Linguist
            to translate the strings.
        \li Starting \QD to design widget-based UIs for applications.
        \li Integrated Qt documentation.
        \li Debugging extensions for Qt data types.
    \endlist

    \sa {Projects}, {Files}, {Building}, {Load Qt projects}, {Cross-compile},
    {Manage resources}, {Create Qt translation files}, {Create UI form files},
    {Start Qt Designer}, {Get help}, {Debug applications}
*/

/*!
    \page qtvstools-how-to-install.html
    \ingroup qtvstools-how-to

    \title Install Qt VS Tools

    To install or update Qt VS Tools in Microsoft Visual Studio:

    \list 1
        \li Select \uicontrol Extensions > \uicontrol {Manage Extensions} >
            \uicontrol Online.
        \li Search for \uicontrol {Qt Visual Studio Tools}.
            \image qtvstools-manage-extensions.webp {Manage Extensions dialog}
        \li Select \uicontrol Download.
        \li Restart Microsoft Visual Studio to have the changes take effect.
    \endlist
*/

/*!
    \page qtvstools-tutorial-qt-widgets-application.html
    \ingroup qtvstools-tutorials

    \title Tutorial: Qt Widgets application

    This tutorial illustrates how to use Qt VS Tools to create a \l {Qt Widgets}
    application. You will create a project using a project wizard and design a
    widget-based UI using \QD.

    \section1 Before you start

    Before you start, you have to:

    \list
        \li \l {Install Qt VS Tools}
        \li \l {Add Qt versions}
    \endlist

    \section1 Create a Qt Widgets application project

    To create a Qt Widgets application project in Visual Studio:

    \list 1
        \li Select \uicontrol File > \uicontrol New > \uicontrol Project, and
            search for \uicontrol {Qt Widgets Application}.
        \li Select the project wizard, and then select \uicontrol Next.
        \li In the \uicontrol {Project name} field, enter \e AddressBook,
            and then select \uicontrol OK.
        \li To acknowledge the \uicontrol Welcome dialog, select
            \uicontrol Next.
        \li Set up the \uicontrol Debug build configuration and select the
            modules to include in the project:
            \image qtvstools-widgets-app-modules.webp {Selecting Qt modules in Qt Widgets Application Wizard}
            The modules that are typically needed in widget application projects
            are selected by default.
        \li Select \uicontrol Next to continue to the class creation page:
            \image qtvstools-widgets-app-class.webp {Creating a class in Qt Widgets Application Wizard}
        \li In the \uicontrol {Base class} field, enter \uicontrol QWidget as
            the base class type.
        \li Select the \uicontrol {Lower case filenames} check box to
            only use lower case characters in the names of the generated files.
        \li Select the \uicontrol {Precompiled header} check box to use a
            precompiled header file.
        \li Select the \uicontrol {Add default application icon} check box to
            use a default application icon for the application.
        \li Select \uicontrol Finish to create the project.
    \endlist

    You now have a small working Qt application. Select \uicontrol Build >
    \uicontrol {Build Solution} to build it, and then select \uicontrol Debug >
    \uicontrol {Start Without Debugging} (or press \key {Ctrl+F5}) to run it.
    For now, the result is an empty window.

    \section1 Design the main window

    You can use \QD to design the application's main window, which has
    some widgets placed in layouts:

    \image qtvstools-addressbook-mainwindow.webp AddressBook's main dialog

    By default, \QD opens in Visual Studio. To open it as a stand-alone
    application, select \uicontrol Detach.

    For more information about using \QD, see the \l{Qt Designer Manual}.

    \section2 Add widgets

    To add widgets to the UI and to set properties for them:

    \list 1
        \li In Visual Studio's Solution Explorer, double-click the
            \c addressbook.ui file to open it in \QD.
        \li In \QD's \uicontrol {Widget Box}, select \uicontrol {List Widget} and
            Drag it to the form to add a \l QListWidget.
        \li In the \uicontrol {Property Editor}, set the \c ObjectName property
            to \e addressList.
        \li Drag two \uicontrol {Push Button} widgets to the top-right
            corner of the form to add \l QPushButton objects for the
            \uicontrol Add and \uicontrol Delete buttons.
        \li Set the button names to \e addButton and \e deleteButton and
            \uicontrol text property values to \e Add and \e Delete.
        \li Drag two \uicontrol {Label} widgets to the form to add
            \l QLabel objects for displaying the selected item in the list.
        \li Rename the first label to \e nameLabel and change its
            \uicontrol text property to \e {<No item selected>}.
        \li Rename the second label to \e emailLabel and leave its
            \uicontrol text property empty.
    \endlist

    Position the widgets as they appear in the screenshot above.
    To properly position the widgets and to automatically resize
    them when the form is resized, you need to add layouts to the
    form.

    \section2 Add widgets to layouts

    You will need a vertical layout for the buttons as well as a spacer to push
    the buttons to the top of the layout. In addition, you will need a second
    layout to manage the positioning of the other widgets as well as the button
    layout.

    To add widgets to layouts:

    \list 1
        \li Drag a \uicontrol {Vertical Spacer} item to the form to add a
            spacer.
        \li Select the buttons and the spacer, and then select \uicontrol Form >
            \uicontrol {Lay Out Vertically} to add a vertical layout
            (\l QVBoxLayout).
        \li Select the list widgets, the two labels, and the button layout,
            and then select \uicontrol Form > \uicontrol {Lay Out in a Grid} to
            add a grid layout (\l QGridLayout).

            \note Make sure that the labels are almost as wide as the form.
            Otherwise, the grid layout will make them only as wide as the
            address list.
        \li Select \uicontrol Form > \uicontrol Preview to preview your form
            without compiling it.
        \li Select \uicontrol File > \uicontrol Save to save the form.
    \endlist

    Build and run the application to check the main window.

    \section1 Add a dialog

    Now that the main window is ready, you can move on to add functionality to
    the application. To have the application open a dialog when the user clicks
    the \uicontrol Add button, you must create an \uicontrol {Add Address}
    dialog and invoke the dialog from a slot that you connect to the
    \uicontrol Add button.

    You can use a Qt file wizard in Visual Studio to create a UI form that
    has the \uicontrol OK and \uicontrol Cancel buttons connected to the
    QDialog::accept() and QDialog::reject() slots, respectively. You can use \QD
    to add other widgets to the form.

    \section2 Create the dialog

    To add a dialog to a project:

    \list 1
        \li In Visual Studio, select \uicontrol Project >
            \uicontrol {Add New Item} > \uicontrol Installed >
            \uicontrol {Visual C++} > \uicontrol Qt >
            \uicontrol {Qt Widgets Class}.
        \li To acknowledge the \uicontrol Welcome dialog, select
            \uicontrol Next.
        \li In the \uicontrol Name field, enter \e AddDialog.
            \image qtvstools-qt-widget-class-wizard.webp {Creating a class in Qt Widgets Class Wizard}
        \li In the \uicontrol {Base class} field, enter \uicontrol QDialog as
            the base class type.
        \li Select the \uicontrol {Multiple inheritance} radio button.
        \li Select the \uicontrol {Lower case filenames} check box to
            only use lower case characters in the names of the generated files.
        \li Select \uicontrol Finish to create source, header, and UI files for
            the dialog.
    \endlist

    \section2 Design the dialog

    \image qtvstools-addressbook-adddialog.png Add Address Dialog

    To design the dialog:

    \list 1
        \li In Visual Studio's Solution Explorer, double-click the
            \c adddialog.ui file to open it in \QD.
        \li In \QD, set \e {Add Address} as the \uicontrol windowTitle.
        \li Add a \uicontrol Label to the form and set its \uicontrol objectName
            property to \e nameText and \uicontrol text property to \e {Name:}.
        \li Add another \uicontrol Label and set its \uicontrol objectName
            property to \e emailText and \uicontrol text property to
            \e {Email:}.
        \li Add a \uicontrol {Line Edit} (\l QLineEdit) and set its
            \uicontrol objectName property to \e nameEdit. Leave the
            \uicontrol text property empty.
        \li Add another \uicontrol {Line Edit} and set its \uicontrol objectName
            property to \e emailEdit. Leave the \uicontrol text property empty.
        \li Select the labels and line edits, and then select \uicontrol Form >
            \uicontrol {Lay Out in a Grid} to add a grid layout.
        \li Add a \uicontrol {Push Button} and set its \uicontrol objectName
            property to \e okButton and \uicontrol text property to \e OK.
        \li Add a horizontal spacer to the left of the button.
        \li Add a horizontal layout for the spacer and the button.
        \li Add a vertical spacer between the labels and the button.
        \li Add a vertical layout for the labels and the spacer.
        \li Add a grid layout for both layouts.
        \li Select \uicontrol Form > \uicontrol Preview to preview your form
            without compiling it.
        \li Select \uicontrol File > \uicontrol Save to save the form.
    \endlist

    \section1 Connect to the dialog's OK button

    To have the \uicontrol OK button invoke the QDialog::accept() slot, click
    the \uicontrol {Edit Signals/Slots} toolbar button to enter
    \l {Qt Designer's Signals and Slots Editing Mode}.

    Click the \uicontrol OK button, drag the mouse cursor to an empty area of
    the form, and release the mouse button. In the
    \uicontrol {Configure Connection} dialog, connect the button's
    QPushButton::clicked() signal to the form's QDialog::accept() slot.

    \section1 Open dialogs from the main window

    To invoke the dialog when the user selects \uicontrol Add in the main
    window, you must add a slot to the \c AddressBook class and invoke
    \c AddDialog from this slot.

    Forms that you create using \QD call QMetaObject::connectSlotsByName() to
    establish connections between signals that the form's child widgets
    emit and slots that follow the naming convention \c {on_<sender>_<signal>()}.
    For the application to react appropriately when the user clicks the
    \uicontrol Add button, you must implement a slot called
    \c{on_addButton_clicked()}.

    To implement the slot, open the \c addressbook.h file in Visual Studio and
    add a declaration for the slot:

    \badcode
    private slots:
        void on_addButton_clicked();
    \endcode

    Then open \c addressbook.cpp, and add the slot definition:

    \badcode
    void AddressBook::on_addButton_clicked()
    {
        AddDialog dialog(this);
        dialog.exec();
    }
    \endcode

    To connect to some other signal, you must add the signal to the
    \c AddressBook class. This requires editing both the header file,
    \c addressbook.h, and the implementation file, \c addressbook.cpp.

    Include \c adddialog.h to \c addressbook.cpp:

    \quotefromfile AddressBook/addressbook.cpp
    \skipto adddialog
    \printuntil adddialog.h

    To test your changes, build and run the application. Select the
    \uicontrol Add button to open the \uicontrol {Add Address} dialog, and then
    select \uicontrol OK to close it.

    \section1 Add items to the list widget

    When the user selects \uicontrol OK, an item should be added to the
    QListWidget. To implement this function, change the code in the
    \c {on_addButton_clicked()} slot, as follows:

    \skipto AddDialog dialog(this);
    \printuntil }
    \printuntil }

    The dialog is executed. If the user accepts it by selecting \uicontrol OK,
    the \uicontrol Name and \uicontrol Email fields are extracted and a
    QListWidgetItem that has the specified information is created.

    \section1 Display the selected item

    To update the \c nameLabel and the \c emailLabel at the bottom of the form
    when the user selects an item in the list widget, add another slot to the
    \c AddressBook class.

    In the \c addressbook.h file, add the following code in the
    \c{private slots} section of the class:

    \quotefromfile AddressBook/addressbook.h
    \skipto on_addressList_currentItemChanged()
    \printuntil ;

    Then, add the block of code below to \c addressbook.cpp:

    \quotefromfile AddressBook/addressbook.cpp
    \skipto on_addressList_currentItemChanged()
    \printuntil /^\}/

    The naming convention enables this slot to be automatically connected
    to the QListWidget::currentItemChanged() signal of \c{addressList} and
    be invoked whenever the selected item in the list changes.

    \section1 Add functionality for the Delete button

    To implement a slot for the \uicontrol Delete button, open the
    \c addressbook.h file in Visual Studio and add a declaration for the
    \c on_deleteButton_clicked() slot. Then open \c addressbook.cpp and add the
    slot definition for \c on_deleteButton_clicked().

    Type the following code in the slot's body:

    \skipto on_deleteButton_clicked()
    \printuntil /^\}/

    Your application is now complete.

    \sa {Tutorial: Qt Quick application}
*/

/*!
    \page qtvstools-tutorial-qt-quick-application.html
    \ingroup qtvstools-tutorials

    \title Tutorial: Qt Quick application

    This tutorial illustrates how to use Qt VS Tools to create a \l {Qt Quick}
    application. You will create a project using a project wizard and design a
    Qt Quick UI. In addition, you will learn how to add QML module definitions
    and QML files to your projects.

    \section1 Before you start

    Before you start, you have to:

    \list
        \li \l {Install Qt VS Tools}
        \li \l {Add Qt versions}
    \endlist

    \section1 Create a Qt Quick application project

    To create a Qt Quick application project in Visual Studio:

    \list 1
        \li Select \uicontrol File > \uicontrol New > \uicontrol Project, and
            search for \uicontrol {Qt Quick Application}.
        \li Select the project wizard, and then select \uicontrol Next.
        \li In the \uicontrol {Project name} field, enter \e QuickAddressBook,
            and then select \uicontrol Create.
        \li To acknowledge the \uicontrol Welcome dialog, select
            \uicontrol Next.
        \li To set up debug and release build configurations, click in
            \uicontrol {Qt Modules}, and select the \uicontrol {Qt Quick} and
            \uicontrol {Qt Quick Controls} modules to include in the project:
            \image qtvstools-qtquick-app-modules.webp {Selecting Qt modules in Qt Quick Application Wizard}
        \li Select \uicontrol Finish to create the project.
    \endlist

    You now have a small working Qt Quick application. Select \uicontrol Build >
    \uicontrol {Build Solution} to build it, and then select \uicontrol Debug >
    \uicontrol {Start Without Debugging} (or press \key {Ctrl+F5}) to run it.
    For now, the result is an empty window.

    \section1 Design the main window

    The wizard created a main QML file for you, which declares a root object of
    the type \l Window. You can change the file to design the application's main
    window.

    Specify values for the Window \c color and \c title properties to set the
    background color and title of the application main window:

    \quotefromfile QuickAddressBook/main.qml
    \skipto Window {
    \printuntil title

    \section2 Add a button

    To create the \uicontrol Add button, declare an object of the \l Button type
    from the \l {Qt Quick Controls} module. Set the value of the button \c text
    property to \e Add and the value of the \c font.pointSize property to \e 24:

    \skipto Button {
    \printuntil font.pointSize

    When you run the application, you should now see this:

    \image qtvstools-quick-addressbook-mainwindow.png QuickAddressBook's main window

    \section2 Connect the button to an action

    QML has a signal and handler mechanism, where the signal is the event and
    the signal is responded to through a signal handler. When a signal is
    emitted, the corresponding signal handler is invoked. Placing logic such
    as a script or other operations in the handler allows the component to
    respond to the event.

    To receive a notification when a particular signal is emitted for a
    particular object, the object definition should declare a signal handler
    named \c on<Signal>, where \c <Signal> is the name of the signal, with
    the first letter capitalized. The signal handler should contain the
    JavaScript code to be executed when the signal handler is invoked.

    The \l Button type has a \c clicked signal, which is emitted when the users
    click the button. To invoke a popup for adding an address book entry when
    the users select the \uicontrol Add button in the main window, you must
    connect the \c onClicked signal handler of the button to the \c open()
    method of the popup. You will add the popup as a separate QML type later.

    \printuntil }

    \section2 Add a list model

    \image qtvstools-quick-addressbook-entries.png QuickAddressBook entries

    Within the Window, declare an object of the \l ListModel type with the
    \c id \e addressList for storing the contact data. A list model defines
    a free-form list data source:

    \quotefromfile QuickAddressBook/main.qml
    \skipto ListModel {
    \printuntil }

    \section2 Declare a popup

    Declare an object of the custom \c NewAddressPopup type that
    defines the popup where the users will add address book entries.
    Use the \c onAddressAdded signal handler to append address
    book entries to the \e addressList model:

    \printuntil }
    \printuntil }

    You will create the \c NewAddressPopup type later.

    \section2 Position the button

    Declare an object of \l ColumnLayout type to position the \l Button object
    and an instance of the \l Repeater type:

    \printuntil }

    Anchor the column layout to the left and right edges of its parent to make
    the application scalable on different screen sizes. Set the \c spacing
    between the rows in the column to \e 0.

    \section2 Add a repeater

    The \l Repeater type creates many similar items. It
    has a model and a delegate: for each entry in the model, the delegate is
    instantiated in a context seeded with data from the model. Enclose the
    repeater in an instance of a positioner type such as a \l ColumnLayout to
    visually position the delegate items that the repeater creates.

    Specify \e addressList as the \c model to use for the repeater:

    \printuntil anchors.right

    Declare an object of the custom \c AddressBookItem type that the
    repeater will use to instantiate address book entries:

    \printuntil id:

    You will create the \c AddressBookItem type later.

    \section2 Connect the Remove button to an action

    Use the \c onRemoved signal handler to remove an address book entry from the
    list when the user clicks its \uicontrol Remove button.

    \printuntil }

    \section1 Add a popup

    Now that the main window is ready, you can move on to create the popup
    where users can add address book entries. The \c AddressBookItem type
    specifies that the repeater instantiates the data that the users enter
    in the main window.

    \image qtvstools-quick-addressbook-popup.png QuickAddressBook's popup

    You can use a Qt file wizard in Visual Studio to create a custom type
    that defines the popup.

    To create custom QML types, you must first add a QML Module Definition
    (\c qmldir) file to the project.

    \section2 Add a QML module definition

    A QML module definition (\c qmldir) maps each custom QML type to its
    corresponding source file.

    To add a QML module definition, select \uicontrol Project >
    \uicontrol {Add New Item} > \uicontrol {Installed} > \uicontrol {Visual C++}
    > \uicontrol Qt > \uicontrol {Qt QML Module Definition} > \uicontrol Add.

    In the \c qmldir file, add QML type definitions for \e AddressBookItem and
    \e NewAddressPopup:

    \quotefile QuickAddressBook/qmldir

    Next, you will create the QML types.

    \section2 Create a popup

    To add a custom QML type to the project:

    \list 1
        \li Select \uicontrol Project > \uicontrol {Add New Item} >
            \uicontrol {Installed} > \uicontrol {Visual C++} > \uicontrol {Qt} >
            \uicontrol {Qt QML File} > \uicontrol Add.
        \li In the \uicontrol Name field, enter \e NewAddressPopup.
        \li Select \uicontrol Finish to create a custom QML type.
    \endlist

    \section2 Design the popup

    In \e NewAddressPopup.qml, declare a root object of the type \l Popup to
    create a popup that opens in a \l Window. A popup does not
    provide a layout of its own, so you will use a \l ColumnLayout and a
    \l RowLayout to position the \uicontrol Name and \uicontrol {E-Mail Address}
    fields.

    \quotefromfile QuickAddressBook/QuickAddressBookTypes/NewAddressPopup.qml
    \skipto Popup {
    \printuntil id:

    Set the \c modal property to \c true to specify that the popup is modal. Set
    the \c focus property to \c true to specify that the popup requests focus:

    \printuntil focus:

    Specify values for the \c width, \c x, and \c y properties to set the
    position and size of the popup on top of the main window:

    \printuntil y:

    \section2 Reset popup controls

    When the popup opens, the \uicontrol Name and \uicontrol {E-Mail Address}
    fields should display placeholder text and any values entered previously
    should be cleared. You use the \c onOpened signal handler to reset the
    values of the fields and give focus to the \uicontrol Name field:

    \printuntil }

    \section2 Position fields

    Use an instance of the \l ColumnLayout type to position the \l TextField
    objects that specify the \uicontrol Name and \uicontrol {E-Mail Address}
    fields of the popup:

    \skipto ColumnLayout {
    \printuntil id: addrField
    \printuntil }
    \printuntil }

    \section2 Position buttons

    Use an instance of a \l RowLayout type to position two \l Button objects
    that specify the \uicontrol Add and \uicontrol Cancel buttons:

    \printuntil Layout.fillWidth: true

    \section2 Connect buttons to actions

    When the users click the \uicontrol Add button, the values they entered to
    the \uicontrol Name and \uicontrol {E-Mail Address} fields are added to the
    address list in the main window and the popup is closed.

    To enable this, add the \c {addressAdded(string newName, string newAddr)}
    signal:

    \quotefromfile QuickAddressBook/QuickAddressBookTypes/NewAddressPopup.qml
    \skipto addressAdded(
    \printuntil )

    Connect the \c onClicked signal handler of the \uicontrol Add button to
    the \c addressAdded() signal and to the popup's \c close() method:

    \skipto Button {
    \printuntil }
    \printuntil }

    For the \uicontrol Cancel button, connect the \c onClicked signal handler to
    the to the popup's \c close() method to close the popup without saving the
    data:

    \printuntil }

    \section1 Define an address book entry

    The custom \c AddressBookItem type specifies how to present address book
    entries in the main window.

    Select \uicontrol Project > \uicontrol {Add New Item} > \uicontrol Installed
    > \uicontrol {Visual C++} > \uicontrol Qt > \uicontrol {Qt QML File} >
    \uicontrol Add, to create a new QML file called \e AddressBookItem.qml.

    \section2 Design the entry

    First, you will declare a root object of type \l Rectangle. It is one of the
    basic building blocks you can use to create an application in QML. Give it
    an \c id to be able to refer to it later.

    \quotefromfile QuickAddressBook/QuickAddressBookTypes/AddressBookItem.qml
    \skipto Rectangle {
    \printuntil id:

    To use alternating colors for rows, set the value of the \c color property:

    \printuntil color:

    Anchor the rectangle to the left and right edges of its parent to make
    the application scalable on different screen sizes. Bind the rectangle
    \c height property to the height of the text items it will contain:

    \printuntil height:

    \section2 Connect the Remove button to an action

    Add the \c removed() signal that you will connect to the \onClicked
    signal handler of the remove button. This removes an address book entry
    from the main window when users click the button:

    \printuntil signal removed()

    \section2 Position the button and text

    Use instances of the \l RoundButton and \l Text types within an instance of
    a \l RowLayout type to define an address book entry:

    \printuntil }

    \section2 Format the text

    Set the value of the \c text property to combine the values of the \c name
    and \c addr fields from the popup and to use bold and italic formatting for
    the values:

    \printuntil }

    Your application is now complete.

    \sa {Tutorial: Qt Quick debugging}, {Tutorial: Qt Widgets application}
*/

/*!
    \page qtvstools-tutorial-debug-qt-quick.html
    \ingroup qtvstools-tutorials

    \title Tutorial: Qt Quick debugging

    This tutorial illustrates how to use Qt VS Tools to debug the
    \l {Tutorial: Qt Quick Application}{Qt Quick tutorial application},
    \e QuickAddressBook. After you enable QML debugging for the project,
    you can set breakpoints in QML files and step through the execution
    of code. While in break mode, you can watch variables and change their
    values, as well as evaluate arbitrary expressions.

    For more information about all the options you have, see
    \l {Debugging Qt Quick Applications}.

    \section1 Before you start

    Before you start, you have to:

    \list
        \li \l {Install Qt VS Tools}
        \li \l {Add Qt versions}
        \li \l {Tutorial: Qt Quick Application}{Create a Qt Quick Application}
        \li \l {Enable QML debugging}
    \endlist

    \section1 Set a breakpoint

    Select \uicontrol File > \uicontrol Open > \uicontrol {File or Solution} to
    open the \e QuickAddressBook solution.

    To look at the code that adds a new contact, add a breakpoint in
    \e {NewAddressPopup.qml} by clicking the line that implements the
    \c onClicked signal handler and selecting \uicontrol {Debug} >
    \uicontrol {Toggle Breakpoint} (or pressing \key F9).

    \image qtvstools-quick-addressbook-breakpoint.webp {Setting a breakpoint}

    The red circle indicates that a breakpoint is now set on that line.

    \section1 Start debugging

    Select \uicontrol Debug > \uicontrol {Start Debugging} or press \key F5.

    Once the application starts, select \uicontrol {Add} to create a new
    address book entry. Enter a name and email address, and select
    \uicontrol {Add} again to add the entry to the address book.

    When the debugger hits the breakpoint, it interrupts the application.
    Qt VS Tools displays the nested function calls leading to the current
    position as a call stack trace. You can view and change the values of
    local variables.

    \image qtvstools-quick-addressbook-breakpoint-hit.webp {Viewing a variable}

    \section1 Step through code

    Select \uicontrol {Debug} > \uicontrol {Step Into} or press \key F11 to step
    into the code in the stack. The \e {NewAddressPopup.qml} file opens in the
    code editor at the function that creates a new address book entry.

    \image qtvstools-quick-addressbook-step-into.webp {Stepping into code}

    \section1 Watch variable values

    The \uicontrol {Autos} and \uicontrol {Locals} windows show a subset of
    local variables that Visual Studio considers possibly interesting based
    on the location of the breakpoint. To watch a particular variable or
    expression, set a watch in the \uicontrol {Watch 1} view.

    \image qtvstools-quick-addressbook-watch.webp {Watching a variable}

    Step through the code to see how the information changes in the view.

    \section1 Evaluate expressions

    To execute JavaSript commands in the context of the current stack frame, open
    the \uicontrol {Immediate Commands} window and type the expression to
    evaluate.

    \section1 Remove the breakpoint

    To remove the breakpoint, select \uicontrol {Debug} >
    \uicontrol {Toggle Breakpoint} (or press \key F9).

    \sa {Cross-compile}, {Debug applications}, {Debug on Linux},
    {Debugging Qt Quick applications}
*/


/*!
    \page qtvstools-reference-projects.html
    \ingroup qtvstools-reference

    \title Projects

    Qt VS Tools provide wizards for creating several types of Qt and Qt Quick
    projects and files that you can add to the projects, such as classes, form
    files, or custom QML types.

    You can also load existing Qt projects into Visual Studio for further
    development.

    You can use the integrated Qt Resource editor to manage the resources in
    Qt projects.

    In addition, you can create a Qt translation source (TS) file and start
    Qt Linguist from Visual Studio to translate the strings in your application.

    To create Qt projects, select \uicontrol File > \uicontrol New >
    \uicontrol Project, and search for Qt.

    \image qtvstools-projects.webp {Qt project wizard templates}

    You can create following types of projects.

    \table
    \header
        \li Template
        \li Creates
    \row
        \li \uicontrol {Qt ActiveQt Server}
        \li A simple ActiveX server.
    \row
        \li \uicontrol {Qt Class Library}
        \li A basic Qt-based dynamic library.
    \row
        \li \uicontrol {Qt Console Application}
        \li A basic Qt console application.
    \row
        \li \uicontrol {Qt Designer Custom Widget}
        \li A \QD custom widget plugin.
    \row
        \li \uicontrol {Qt Empty Application}
        \li An empty Qt application project.
    \row
        \li \uicontrol {Qt Quick Application}
        \li A Qt Quick application project.
    \row
        \li \uicontrol {Qt Widgets Application}
        \li A simple Qt widgets application with one form.
    \endtable

    Each Qt project provides a wizard that allows you to specify the Qt modules
    required for your project. For some projects, the wizard will also generate
    a skeleton class or QML type instance that you can use to get started.

    To start writing Qt code and building your projects, you must tell Visual
    Studio where to find the \l{Add Qt versions}{Qt version} that you want
    to use.

    The application tutorials contain examples of using the project templates:

    \list
        \li \l {Tutorial: Qt Widgets Application}
        \li \l {Tutorial: Qt Quick Application}
    \endlist

    \sa {Add Qt versions}, {Files}
*/

/*!
    \page qtvstools-reference-files.html
    \ingroup qtvstools-reference

    \title Files

    You can use file templates to add files to projects.

    Select \uicontrol Project > \uicontrol {Add New Item} >
    \uicontrol Installed > \uicontrol {Visual C++} > \uicontrol Qt.

    \image qtvstools-add-new-item.webp {Add New Item dialog}

    \table
    \header
        \li Template
        \li Adds
    \row
        \li \uicontrol {Qt Class}
        \li A Qt class to an Application project.
    \row
        \li \uicontrol {Qt Dialog Form File (Button Bottom)}
        \li A dialog with \uicontrol OK and \uicontrol Cancel buttons at
            its bottom to a Qt Widgets Application project.
    \row
        \li \uicontrol {Qt Dialog Form File (Button Right)}
        \li A dialog with buttons at its right edge to a
            Qt Widgets Application project.
    \row
        \li \uicontrol {Qt MainWindow Form File}
        \li A form file to a Qt Widgets Application project.
    \row
        \li \uicontrol {Qt QML File}
        \li A custom QML type to a Qt Quick Application project.
    \row
        \li \uicontrol {Qt QML Module Definition}
        \li A \c qmldir file that specifies the custom QML types used in a
            Qt Quick Application project.
    \row
        \li \uicontrol {Qt Resource File}
        \li A Qt resource file (.qrc) to an Application project.
    \row
        \li \uicontrol {Qt Translation File}
        \li A Qt translation file (.ts) to an Application project.
    \row
        \li \uicontrol {Qt Widget Form File}
        \li A Qt Widgets form file (.ui) to an Application project.
    \row
        \li \uicontrol {Qt Widgets Class}
        \li A Qt Widgets class to a Qt Widgets Application project.
    \endtable

    The following topics describe how to add different types of files to
    projects:

    \list
        \li \l {Create UI form files}
        \li \l {Manage resources}
        \li \l {Create Qt translation files}
    \endlist

    The application tutorials contain examples of using file templates to add
    files to projects:

    \list
        \li \l {Tutorial: Qt Widgets Application}
        \li \l {Tutorial: Qt Quick Application}
    \endlist

    \sa {Projects}
*/

/*!
    \page qtvstools-how-to-load-qt-projects.html
    \ingroup qtvstools-how-to

    \title Load Qt projects

    If your Qt projects have \c .pro files that you use to build them with
    \l {qmake Manual}{qmake}, you can load them to Visual Studio and convert
    them into solutions. You can then use Visual Studio to build them.

    To open Qt projects (.pro) in Visual Studio, select \uicontrol Extensions >
    \uicontrol {Qt VS Tools} > \uicontrol {Open Qt Project File (.pro)}.

    \sa {Building}, {Configuring builds}
*/

/*!
    \page qtvstools-explanation-configuring-builds.html
    \ingroup vstools-explanation

    \title Configuring builds

    Visual Studio uses the Project System to build C++ projects, where MSBuild
    provides the project file format and build framework. Qt VS Tools integrate
    with MSBuild, so that you design and build Qt applications as Visual Studio
    projects. In addition, Visual Studio supports using \l {Build with CMake}
    {CMake} to build projects.

    When you create new Qt application projects, you can select whether to use
    MSBuild or CMake to build them. The wizards create the necessary files for
    you.

    \image qtvstools-wizard-cmake.webp {Selecting CMake in the application wizard}

    You can load .pro files to Visual Studio to continue developing existing Qt
    application projects that you configured to use qmake.

    \section1 MSBuild configurations

    At very general level, MSBuild works as follows:

    \list
        \li An MSBuild project consists of references to source files and
            descriptions of actions for processing those source
            files that are called \e targets.
        \li The build process runs in the context of a project configuration,
            such as \e Debug or \e Release. A project may contain any number
            of configurations.
        \li Data associated to source files and the project itself is accessible
            through \e properties. MSBuild properties are name-value definitions,
            specified per configuration. That is, each configuration has its own
            set of property definitions.
    \endlist

    \image qtvstools-msbuild-diagram.png {Diagram showing Visual Studio Project and MSBuild}

    \section2 Properties

    You can set property values for the project itself (\e {project scope}) or
    for a specific file in the project (\e {file scope}), either globally or
    locally:

    \list
        \li Project scope properties are always global. For example, the
            project's output directory or target file name.
        \li Properties that apply to source files can be global, in
            which case the same value applies to all files. For example,
            you can set the default compiler warning level globally at
            level 3.
        \li You can override such a global, file-scope definition for a
            specific file by defining a local property with the same name.
            For example, compile one of the source files with warning level 4.
        \li Global definitions are stored in the project file or imported from
            property sheet files.
        \li Local property definitions are stored in the project file, within
            the associated source file references.
    \endlist

    \section2 Qt settings

    Qt VS Tools provide the MSBuild project system with a set of
    Qt-specific targets that describe how to use the appropriate Qt tools to
    process files such as moc headers.

    \image qtvstools-qt-project-settings.webp {Qt Project Settings}

    Qt settings are fully-fledged project properties, which ensures that:

    \list
        \li Changes in Qt settings are synchronized with all the other
            properties in the project.
        \li You can specify Qt settings, such as Qt versions and modules,
            separately for each build configuration.
        \li You can override compiler properties for files that Qt tools
            generate in project settings
        \li You can share Qt settings within a team or organization by
            exporting and importing them to and from shared \e {property sheet}
            files (\c .props).
    \endlist

    \sa {Add Qt versions}, {Cross-compile}, {Load Qt projects}, {Building}
*/

/*!
    \page qtvstools-how-to-add-qt-versions.html
    \ingroup qtvstools-how-to

    \title Add Qt versions

    Qt VS Tools provide you with basic Qt version management that enables you to
    use multiple Qt versions in parallel. For example, Qt 5.15.11 and 6.5.0.
    You have to add at least one Qt version that was built for MSVC to be able
    to create Qt projects.

    \image qtvstools-qt-versions.webp {Qt Versions}

    To add Qt versions:

    \list 1
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol {Qt} > \uicontrol {Versions} > \inlineimage plus.png
            .
        \li In the \uicontrol Version field, enter a name for the Qt version.
            If you add the path to Qt first, this field is filled automatically.
        \li In the \uicontrol Host field, select \uicontrol Windows, unless you
            want to cross-compile the application for an embedded Linux device.
        \li In the \uicontrol Path field, enter the path to the qmake.exe for
            the Qt version.
            For example: \c {C:\Qt\6.2.0\msvc2019_64\bin\qmake.exe}.
        \li In the \uicontrol Default field, select the Qt version to use
            by default when creating new projects or importing a project from a
            \c {.pro} file.
        \li Select \uicontrol OK.
    \endlist

    To remove a Qt version, select \inlineimage minus.png
    .

    \sa {Select Qt versions for a project}, {Cross-compile}, {Load Qt projects}
*/

/*!
    \page qtvstools-how-to-select-qt-versions-for-project.html
    \ingroup qtvstools-how-to

    \title Select Qt versions for a project

    To select another Qt version than the default Qt version for a project:

    \list 1
        \li In \uicontrol {Solution Explorer}, right-click the project and
            select \uicontrol Properties in the context menu.
        \li Select \uicontrol {Qt Project Settings}.
            \image qtvstools-qt-project-settings.webp {Qt Project Settings dialog}
        \li In \uicontrol {Qt Installation}, select the Qt version.
    \endlist

    \sa {Add Qt versions}, {Cross-compile}
*/

/*!
    \page qtvstools-explanation-building.html
    \ingroup qtvstools-explanation

    \title Building

    Qt VS Tools includes MSBuild rules and targets specific to
    \l {Using the Meta-Object Compiler (moc)}{Meta-Object Compiler (moc)},
    \l {User Interface Compiler (uic)}, and \l {Resource Compiler (rcc)}.
    These rules are referred to as \e Qt/MSBuild. They enable running moc,
    rcc and uic in parallel processes and setting build options, such as
    selecting project items to process and the tools to process them.
    Further, source files that the Qt tools generate are added to the C++
    compilation during the build process, so you do not need to include
    generated files in projects.

    You can set options for each Qt tool either globally at project level
    or for specific files. To set global options for handling files at project
    level:

    \list
        \li Select \uicontrol Properties in the context menu of the project.
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol {Qt Project Settings}.
    \endlist

    \image qtvstools-qt-project-settings.webp {Qt Project Settings}

    To set options for handling a specific file, select \uicontrol Properties in
    the context menu of the file. The dialog lists only tools relevant for the
    file type. For example, moc options are available for C++ source and header
    files, whereas uic options are available for UI forms (.ui).

    \section1 Qt/MSBuild project format

    The Qt/MSBuild project file format has changed between Qt VS Tools versions.
    Currently, version 3 and later are supported.

    If you open an existing solution that has version 1 project format, you can
    still build it. If it has version 2 format, you can build it if you set
    additional command line options and set the default Qt version
    to the Qt version that you initially created the project for.

    When you load .pro files, Qt VS Tools automatically converts
    \e {custom build steps} into Qt/MSBuild steps.

    For more information about Qt/MSBuild project format versions, see
    \l {https://github.com/qt-labs/vstools/blob/dev/Tests/ProjectFormats/ProjectFormats.md}
    {Qt VS Tools - Project format versions}.

    \section1 Path to build files

    To set the path to the Qt/MSBuild files, select \uicontrol Extensions >
    \uicontrol {Qt VS Tools} > \uicontrol Options > \uicontrol {Qt/MSBuild}.
    This corresponds to setting the value of the \c QTMSBUILDS environment
    variable.

    \sa {Build solutions that have Qt/MSBuild format 2},
    {Convert solutions to latest Qt/MSBuild format}, {Load Qt projects}
*/

/*!
    \page qtvstools-how-to-build-older-projects.html
    \ingroup qtvstools-how-to

    \title Build solutions that have Qt/MSBuild format 2

    The Qt/MSBuild project format has changed between Qt VS Tools versions.

    To build solutions that have project format 2:

    \list 1
        \li Open the solution.
        \li In the context menu, select \uicontrol Properties >
            \uicontrol {C/C++} > \uicontrol {Command Line} to
            set additional command line options.
        \li In \uicontrol {Additional Options}, enter the following options:
            \c {/std:c++17 /Zc:__cplusplus /permissive-}
            \image qtvstools-convert-project-format.webp {Additional command line options}
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol {Qt} > \uicontrol {Versions}.
        \li In the \uicontrol Default field, select the check box next to the
            Qt version that you initially created the project for.
            \image qtvstools-qt-versions.webp {Qt Versions}
    \endlist

    \sa {Add Qt versions}, {Convert solutions to latest Qt/MSBuild format},
    {Building}
*/

/*!
    \page qtvstools-how-to-convert-project-format.html
    \ingroup qtvstools-how-to

    \title Convert solutions to latest Qt/MSBuild format

    To further develop existing solutions that have old Qt/MSbuild project
    format, convert them to the supported project format version:

    \list 1
        \li Open the solution.
        \li Select \uicontrol Update.
            \image qtvstools-open-solution-update.webp {Opening a solution with old project format}
        \li If you don't see the message, right-click the solution and select
            \uicontrol Qt > \uicontrol {Convert custom build steps to Qt/MSBuild}
            in the context menu.
    \endlist

    \sa {Build solutions that have Qt/MSBuild format 2}, {Building}
*/

/*!
    \page qtvstools-how-to-cross-compile.html
    \ingroup qtvstools-how-to

    \title Cross-compile

    Qt VS Tools support cross-compilation of Qt projects by integrating
    Qt/MSBuild and the Linux development VS workload. This enables you to
    develop widget-based and Qt Quick applications that target both Windows
    and Linux, including embedded devices.

    \section1 Set up cross-compilation

    To develop Qt applications for Linux using Visual Studio:

    \list 1
        \li Install the Desktop development with C++ and Linux development with
            C++ workloads.
        \li Enable the Windows Subsystem for Linux (WSL) and install a
            Linux distribution.
        \li Or, create a connection to a remote Linux build server.
        \li Add the cross-compiled Qt build that resides in a WSL instance
            or the remote build server.
    \endlist

    \section1 Add Qt version for cross-compilation

    To add a Qt version for cross-compilation:

    \list 1
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol {Qt Versions} > \inlineimage plus.png
            to add a new Qt version.
            \image qtvstools-qt-versions.webp {Qt Versions}
        \li In the \uicontrol Version field, enter a name for the Qt version.
            If you add the path to Qt first, this field is filled automatically.
        \li In \uicontrol Host, select \uicontrol {Linux WSL} or
            \uicontrol {Linux SSH}.
        \li In the \uicontrol Path field, enter the path to the Qt installation.
        \li In the \uicontrol Compiler field, enter the cross-compiler to use.
            The default value is g++.
    \endlist

    \section1 Compile on WSL

    Using a WSL instance to run the cross-compiler is faster than using an
    SSH connection to a build host. When using SSH, MSBuild must first upload
    the source files to the remote host, whereas WSL mounts local drives in
    \c /mnt, making file access instantaneous.

    MSBuild assumes that paths specified in options are local paths and maps
    them to corresponding Linux paths rooted on \c /mnt. For example:

    \badcode
    C:\include\foolib maps to /mnt/c/include/foolib
    \endcode

    Using absolute Linux paths as value of \uicontrol Extensions >
    \uicontrol {Qt VS Tools} > \uicontrol Options > \uicontrol {Qt/MSBuild}
    can lead to wrong mappings. For example, \c {/home/user/raspi} maps
    to \c {/mnt/home/user/raspi}.

    To avoid this issue, create symbolic links in \c /mnt to other top-level
    directories in the WSL instance file system.

    \sa {Tutorial: Qt Quick debugging}, {Debug applications}, {Debug on Linux},
    {Enable QML debugging}, {Building}, {Debugging Qt Quick applications}
*/

/*!
    \page qtvstools-how-to-add-form-files.html
    \ingroup qtvstools-how-to

    \title Create UI form files

    You can use \QD to design widget-based UIs.

    To add a new \c .ui file to the project, select \uicontrol Project >
    \uicontrol {Add New Item} > \uicontrol Installed > \uicontrol {Visual C++} >
    \uicontrol Qt > \uicontrol {Qt Widgets Form File}.

    \image qtvstools-qt-widget-class-wizard.webp {Qt Widgets Class Wizard}

    Typically, you need to wrap the code generated for the form file into a
    QWidget subclass to add signals or slots to it. Therefore, Qt VS Tools
    create a \c .h and \c .cpp file for you, along with an empty UI form.

    \sa {Tutorial: Qt Widgets application}, {Start Qt Designer},
    {Qt Designer Manual}
*/

/*!
    \page qtvstools-how-to-start-qt-designer.html
    \ingroup qtvstools-how-to

    \title Start Qt Designer

    To start \QD:

    \list
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol {Launch Qt Designer}.
        \li Double-click a \c .ui file in the Solution Explorer.
    \endlist

    \sa {Create UI form files}, {Qt Designer Manual}

    By default, \QD opens in Visual Studio. To open it as a stand-alone
    application, select \uicontrol Detach.

    To run \QD in a separate window by default:

    \list 1
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
        \uicontrol Options > \uicontrol Qt > \uicontrol General >
        \uicontrol {Qt Designer}.
        \image qtvstools-options-qt-general.webp {Qt General Options}
        \li Set \uicontrol {Run in detached window} to \uicontrol True.
    \endlist
*/

/*!
    \page qtvstools-how-to-manage-resources.html
    \ingroup qtvstools-how-to

    \title Manage resources

    Adding new resources to a Qt project is similar to adding resources to a
    normal C++ project. The main difference is that you use Qt resource files
    (\c .qrc ) instead of Windows \c .rc files. Unlike \c .rc files , \c .qrc
    files work on all platforms supported by Qt and are trivial to load from Qt
    code.

    To add new resources:

    \list 1
        \li Select \uicontrol Project > \uicontrol {Add New Item} >
            \uicontrol Installed > \uicontrol {Visual C++} > \uicontrol Qt >
            \uicontrol {Qt Resource File}.
            \image qtvstools-new-project-item-qt-resource-file.webp {Add New Item dialog}
        \li In the \uicontrol Name field, enter a name for the resource file.
        \li In the \uicontrol Location field, specify a location for the file.
        \li Select \uicontrol Add to create a \c .qrc file and to open it in the
            \uicontrol {Qt Resource Editor}.
            \image qtvstools-qrc-editor.png {Qt Resource Editor}
        \li To add resources to the file, select \uicontrol Add >
            \uicontrol {Add Files}.
        \li In the \uicontrol Prefix field, you can change the prefix.
    \endlist

    When referring to the resources later on from Qt code, you must prepend the
    prefix, the file name, and a colon. For example, \c{:/MyProject/print.bmp}.

    \section1 Add prefixes

    To add prefixes to the \c .qrc file, select \uicontrol Add >
    \uicontrol {Add Prefix} in the \uicontrol {Qt Resource Editor}.

    \sa {Start Qt Resource Editor}, {The Qt Resource System}
*/

/*!
    \page qtvstools-how-to-start-qt-resource-editor.html
    \ingroup qtvstools-how-to

    \title Start Qt Resource Editor

    To start Qt Resource Editor, double-click a \c .qrc file in the Solution
    Explorer.

    \image qtvstools-qrc-editor.png {Qt Resource Editor}

    By default, Qt Resource Editor opens in Visual Studio. To run it in a
    separate window, select \uicontrol Detach.

    To run \uicontrol {Qt Resource Editor} in a separate window by default:

    \list
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol Options > \uicontrol {Qt Resource Editor}.
        \li set \uicontrol {Run in detached window} to \uicontrol True.
    \endlist

    \sa {Manage resources}, {The Qt Resource System}
*/

/*!
    \page qtvstools-how-to-create-qt-translation-files.html
    \ingroup qtvstools-how-to

    \title Create Qt translation files

    You can design applications so that they can be adapted to various languages
    and regions without engineering changes. If you mark UI text as translatable,
    you can create Qt translation source (TS) files that contain them and start
    Qt Linguist to translate the strings.

    To add a new translation file to the project:

    \list 1
        \li Select \uicontrol Project > \uicontrol {Add New Item} > \uicontrol Installed >
            \uicontrol {Visual C++} > \uicontrol Qt > \uicontrol {Qt Translation File}.
        \li In \uicontrol {Select a Language}, select a language from the list
            of supported languages. Use \uicontrol Search to filter for a specific
            language.
            \image qtvstools-qt-translation-file-wizard.png
        \li In the \uicontrol {Save as} field, enter a filename for the translation file.
        \li Select \uicontrol Finish to create the file and have it listed in
            \uicontrol {Translation Files} in Visual Studio's Solution Explorer.
        \li Right-click the translation file to open a context menu, and select
            \c lupdate. It finds translatable strings in source, header, and UI
            files and generates or updates TS files.
    \endlist

    After translating the UI text, select \c lrelease in the context menu to
    create QM files out of TS files. The QM file format is a compact binary
    format that the localized application uses to look up translations.

    \sa {Start Qt Linguist}, {Update Qt translation files},
    {Internationalization with Qt}, {Qt Linguist Manual}
*/

/*!
    \page qtvstools-how-to-update-qt-translation-files.html
    \ingroup qtvstools-how-to

    \title Update Qt translation files

    To update all TS or QM files for a project, select \uicontrol Qt >
    \uicontrol {lupdate All .ts Files for Project} or
    \uicontrol {lrelease All .ts Files for Project} in the context menu for the
    project.

    \section1 Run translation tools during builds

    To run \l {Using lupdate}{lupdate} or \l {Using lrelease}{lrelease} when you
    build a project, select \uicontrol {Extensions} > \uicontrol {Qt VS Tools} >
    \uicontrol {Qt Project Settings} > \uicontrol {Qt Translation} >
    \uicontrol {General}, and select the tool to run.

    \image qtvstools-project-properties-qt-translation.webp {Qt Translation properties}

    \section1 Set lupdate properties

    To set properties for running \c lupdate for a project,
    select \uicontrol {Extensions} > \uicontrol {Qt VS Tools} >
    \uicontrol {Qt Project Settings} > \uicontrol {Qt Translation} >
    \uicontrol lupdate.

    \image qtvstools-project-properties-lupdate.webp {lupdate properties}

    Select a property to see its description.

    For a list of properties that you can set in \uicontrol {AdditionalOptions},
    see \l {lupdate options}.

    \section1 Set lrelease properties

    To set properties for running \c lrelease for a project,
    select \uicontrol {Extensions} > \uicontrol {Qt VS Tools} >
    \uicontrol {Qt Project Settings} > \uicontrol {Qt Translation} >
    \uicontrol lrelease.

    \image qtvstools-project-properties-lrelease.webp {lrelease properties}

    Select a property to see its description.

    For a list of properties that you can set in \uicontrol {AdditionalOptions},
    see \l {lrelease options}.

    \sa {Create Qt translation files}, {Start Qt Linguist},
    {Internationalization with Qt}, {Qt Linguist Manual}
*/

/*!
    \page qtvstools-how-to-start-qt-linguist.html
    \ingroup qtvstools-how-to

    \title Start Qt Linguist

    To start Qt Linguist:

    \list
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol {Launch Qt Linguist}.
        \li Double-click a \c .ts file in the Solution Explorer.
    \endlist

    By default, Qt Linguist opens in Visual Studio. To open it as a stand-alone
    application, select \uicontrol Detach.

    To run Qt Linguist in a separate window by default:

    \list 1
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol Options > \uicontrol Qt > \uicontrol General >
            \uicontrol {Qt Linguist}.
            \image qtvstools-options-qt-general.webp {Qt General Options}
        \li Set \uicontrol {Run in detached window} to \uicontrol True.
    \endlist

    \sa {Create Qt translation files}, {Internationalization with Qt},
    {Qt Linguist Manual}
*/

/*!
    \page qtvstools-how-to-get-help.html
    \ingroup qtvstools-how-to

    \title Get help

    By default, Qt VS Tools try to display Qt online documentation when you
    press \key F1. If you often end up in the Qt documentation even though you
    wanted Microsoft documentation, you can turn off this feature and use the
    default shortcut \key {Alt+F1}.

    To access Microsoft documentation when pressing \key F1:

    \list 1
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol Options > \uicontrol Qt > \uicontrol General >
            \uicontrol Help.
            \image qtvstools-options-qt-general.webp {Qt General Options}
        \li Set \uicontrol {Try Qt documentation when F1 is pressed} to
            \uicontrol False.
    \endlist

    \section1 Access offline help

    To read the documentation delivered with your Qt version instead of the
    latest online version, set \uicontrol {Preferred source} to
    \uicontrol Offline.

    \section1 Change Qt online help keyboard shortcut

    To set up another keyboard shortcut for Qt online help:

    \list 1
        \li Select \uicontrol Tools > \uicontrol Options >
            \uicontrol Environment > \uicontrol Keyboard.
            \image qtvstools-options-environment-keyboard.webp {Keyboard options}
        \li In the \uicontrol {Show commands containing} field, enter
            \e {Help.F1Help}.
        \li Select the \uicontrol {Press shortcut keys} field and press your
            preferred keys to add them to the field.
        \li Select \uicontrol Assign, and then select \uicontrol OK.
    \endlist
*/

/*!
    \page qtvstools-how-to-update-intellisense-info.html
    \ingroup qtvstools-how-to

    \title Update IntelliSense info

    Visual Studio provides IntelliSense code editing features for C++ types
    including code completion, parameter info, and member lists.

    To keep IntelliSense info updated also with code generated by
    Qt tools, such as \l {Using the Meta-Object Compiler (moc)}{moc},
    \l {User Interface Compiler (uic)}{uic}, or \l {Resource Compiler (rcc)}
    {rcc}, they run in the background when source files change. If this
    creates too much overhead for large solutions, you can disable the
    \uicontrol {Run Qt tools in background build} option to only update
    the minimum set of Qt build properties needed to ensure that Qt types
    are included in the IntelliSense index.

    If you disable the option and code completion does not work, try to rebuild
    the project. You might have to wait some time before code completion fully
    works after updating a source file. If rebuilding does not help, refresh the
    code model by selecting \uicontrol {Rescan Solution} in the context menu of
    the project.

    \section1 Refresh IntelliSense info

    To refresh IntelliSense info, select \uicontrol Qt >
    \uicontrol {Refresh IntelliSense} in the context menu
    of the project.

    \section1 Set IntelliSense options

    To set options for updating IntelliSense info:

    \list 1
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol Options > \uicontrol Qt > \uicontrol General >
            \uicontrol IntelliSense.
            \image qtvstools-options-qt-general.webp {Qt General Options}
        \li Select options:
            \list
                \li \uicontrol {Auto project tracking} tracks changes and
                    triggers a background build of Qt targets when necessary.
                \li \uicontrol {Show debug information} displays debug
                    information about IntelliSense info updates.
                \li \uicontrol {Verbosity of background build log} sets the
                    amount of info recorded in the background build log.
            \endlist
    \endlist
*/

/*!
    \page qtvstools-how-to-debug-apps.html
    \ingroup qtvstools-how-to

    \title Debug applications

    You can debug:

    \list
        \li Qt C++ applications using the Visual Studio debugger.
        \li Qt Quick applications using the \e {QML debug engine}.
        \li Applications on Linux using GDB.
    \endlist

    You can set breakpoints in C++ and QML files and step through the execution
    of code.
    While in break mode, you can watch variables and change their values, as
    well as evaluate arbitrary expressions. For Qt Quick applications, a QML
    debugging session runs concurrently to a C++ debugging session, which
    enables you to set breakpoints and watch variables in both C++ and QML
    during the same debugging session.

    To start a debugging session:

    \list
        \li Select \uicontrol Debug > \uicontrol {Start Debugging}.
        \li Press \key F5.
    \endlist

    \sa {Tutorial: Qt Quick debugging}, {Cross-compile}, {Debug on Linux},
    {Enable QML debugging}, {Debugging Qt Quick Applications}
*/

/*!
    \page qtvstools-explanation-debugging-qt-quick.html
    \ingroup qtvstools-explanation

    \title Debugging Qt Quick applications

    A debugger lets you see what happens \e inside an application while it runs
    or when it crashes. A debugger can do the following to help you find errors
    in the application:

    \list
        \li Start the application with parameters that specify its behavior.
        \li Stop the application when conditions are met.
        \li Examine what happens when the application stops.
        \li Make changes in the application when you fix an error and continue
            to find the next one.
    \endlist

    \section1 QML debug engine

    A \e {QML debug engine} extends the Visual Studio debugger with features of
    the \l{QML Debugging Infrastructure}{QML debugging infrastructure}, which is
    a part of the \l{Qt QML} module that offers services for debugging,
    inspecting, and profiling applications via a TCP port. The debug engine
    implements interfaces from the Active Debugging 7 (AD7) extensibility
    framework for the Visual Studio debugger.

    \section1 Setting breakpoints

    If a Qt project has QML resource files, starting a debugging session
    (for example, by pressing \key F5) launches the native application and
    connects to the QML debugging infrastructure of that application. You can see
    this in the \uicontrol {Processes} window of the Visual Studio debugger.

    \image qtvstools-quick-addressbook-step-into.webp {Viewing processes}

    The \uicontrol {Processes} window
    lists two processes: a native process and a QML process. The native process
    corresponds to the actual physical process created for the C++ debugging
    session. The QML process does not correspond to any physical process that is
    running on the machine, but represents the connection to the QML debugging
    runtime within the native process.

    The presence of both a native process and a QML process enables setting
    breakpoints both in C++ or QML code. The Visual Studio debugger forwards
    breakpoint requests to the appropriate debug engine. A filled circular
    breakpoint marker in QML code indicates a valid breakpoint. This means that
    a breakpoint request for that file position was sent to the QML runtime
    and was confirmed by it.

    \section1 Examining data

    When a breakpoint is hit, Visual Studio shows the current state of the call
    stack. Unlike other scenarios of debugging applications that mix several
    languages, such as .NET and native debugging, the QML debug engine does not
    provide true mixed mode debugging. It runs concurrently with the native
    debug engine and is not considered to be related to the native process by
    the Visual Studio debugger. Therefore, even though you can debug both C++
    and QML in the same debugging session, the stack that is shown when a QML
    breakpoint is hit includes only QML function calls. The C++ context of those
    calls will not be available.

    As in the case of native debugging, while in break mode, you can
    view and change the values of local variables in the context of the
    currently active call stack frame, as well as create watches for any
    variable or expression. In the Immediate window, you can evaluate any
    expression in the context of the current stack frame.

    Move the mouse over a QML expression to display an instant watch window.
    You can view and change the value of that expression in the current context.

    \sa {Tutorial: Qt Quick debugging}, {Cross-compile}, {Debug applications},
    {Debug on Linux}, {Enable QML debugging}
*/

/*!
    \page qtvstools-how-to-enable-qml-debugging.html
    \ingroup qtvstools-how-to

    \title Enable QML debugging

    To enable QML debugging for a project:

    \list 1
        \li Select \uicontrol {Extensions} > \uicontrol {Qt VS Tools} >
            \uicontrol {Qt Project Settings} > \uicontrol {QML}.
        \li In \uicontrol {Enable QML Debugging}, select \uicontrol {Yes}.
            \image qtvstools-quick-addressbook-enable-qml-debugging.webp {Enabling QML debugging for a project}
        \li Select \uicontrol {OK} to save the project settings.
        \li Select \uicontrol {Build} > \uicontrol {Rebuild Solution} to rebuild
        the project.
    \endlist

    \section1 Disable QML debugging

    To disable processing of all QML debug events by the QML debug engine:

    \list 1
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol Options > \uicontrol Qt > \uicontrol General >
            \uicontrol {QML Debugging}.
            \image qtvstools-options-qt-general.webp {Qt General Options}
        \li Set \uicontrol {Process debug events} to \uicontrol False.
    \endlist

    This effectively excludes the QML debug engine from the debugging
    environment and disables debugging of QML code for all projects.

    \section1 Set debugging connection timeout

    To increase or decrease the timeout for debugging connections in
    milliseconds:

    \list 1
        \li Select \uicontrol Extensions > \uicontrol {Qt VS Tools} >
            \uicontrol Options > \uicontrol Qt > \uicontrol General >
            \uicontrol {QML Debugging}.
        \li Set the value of \uicontrol {Runtime connection timeout}.
    \endlist

    To remove the timeout, set the value to \uicontrol Disabled.

    \sa {Tutorial: Qt Quick debugging}, {Cross-compile}, {Debug applications},
    {Debug on Linux}, {Debugging Qt Quick applications}
*/

/*!
    \page qtvstools-how-to-debug-on-linux.html
    \ingroup qtvstools-how-to

    \title Debug on Linux

    If you have set up Qt VS Tools for \l {Cross-compile}{cross-compilation}
    on Linux, you can debug applications running on Linux devices. First
    launch the application using \c gdbserver and then configure GDB to connect
    to the device and start a remote debugging session.

    \image qtvstools-remote-debugging.jpg

    For this to work, the GDB installed in the WSL must support the target
    device architecture. A simple way to achieve this is to install
    \c gdb-multiarch. To ensure the Visual Studio uses the correct debugger,
    create a symbolic link from \c gdb to \c gdb-multiarch.

    \section1 Set up remote debugging

    To set up the remote debugging session in Visual Studio, you must
    pass additional commands to GDB:

    \list 1
        \li Select \uicontrol Project > \uicontrol Properties >
            \uicontrol {Configuration Properties} > \uicontrol Debugging.
            \image qtvstools-project-properties-debugging.webp {Debugging properties}
        \li In \uicontrol {Debugger to launch}, select \uicontrol {GDB Debugger}.
        \li In \uicontrol {Additional Debugger Commands}, add the following
            commands:

            \badcode
            target extended-remote <IP_address>:<port>
            set remote exec-file <path_to_executable>
            \endcode
    \endlist

    \section1 Set environment variables

    Before starting the remote debugging session:

    \list 1
        \li Set the required environment variables:
            \list
                \li \l{https://man7.org/linux/man-pages/man8/ld.so.8.html}
                    {LD_LIBRARY_PATH} specifies the path to the directory
                    where you installed Qt binaries.
                \li \l {Qt for Embedded Linux}{QT_QPA_PLATFORM} specifies the
                    platform plugin, such as EGLFS, LinuxFB, DirectFB, or Wayland.
                \li \c QT_QPA_PLATFORM_PLUGIN_PATH specifies the path to the
                    directory where you installed the platform plugin.
                \li For the \l {EGLFS} platform, \c QT_QPA_EGLFS_PHYSICAL_WIDTH
                    and \c QT_QPA_EGLFS_PHYSICAL_HEIGHT specify the screen width
                    and height in millimeters.
                \li \l{QML Import Path}{QML2_IMPORT_PATH} specifies the path to
                    the directory where you installed QML modules.
            \endlist
        \li Launch \c gdbserver on the device.
    \endlist

    \section1 Start remote debugging

    Press \key F5 to start the remote debugging session.

    \section1 Set up debugging on Linux devices

    To debug Qt Quick applications on Linux devices:

    \list 1
        \li Enable QML debugging for the project.
        \li Select \uicontrol Project > \uicontrol Properties >
            \uicontrol {Configuration Properties} > \uicontrol Debugging
            to set up program arguments for starting a QML debugging session.
        \li In \uicontrol {Debugger to launch}, select \uicontrol {GDB Debugger}.
        \li In \uicontrol {Additional Debugger Commands}, add the following
            command:

            \badcode
            -qmljsdebugger=port:<port>,host:<IP_address>,block
            \endcode
    \endlist

    \sa  {Tutorial: Qt Quick debugging}, {Cross-compile}, {Debug applications},
    {Enable QML debugging}, {Debugging Qt Quick applications}
*/
